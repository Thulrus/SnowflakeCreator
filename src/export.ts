/**
 * export.ts
 * 
 * Handles SVG export functionality for laser cutting.
 * Generates a clean, standalone SVG file with only the snowflake paths.
 */

import { SymmetryManager } from './symmetry';

/**
 * Configuration for laser-cutter compatible SVG export.
 */
export interface ExportConfig {
  strokeColor: string;
  strokeWidth: number;
  viewBoxSize: number;
  includeBackground: boolean;
}

/**
 * Default export configuration optimized for laser cutting.
 * Red stroke at 0.1mm is a common standard for cut lines.
 */
export const DEFAULT_EXPORT_CONFIG: ExportConfig = {
  strokeColor: '#FF0000', // Red for laser cutting
  strokeWidth: 0.1, // 0.1mm hairline for cutting
  viewBoxSize: 1000,
  includeBackground: false,
};

/**
 * Manages SVG export for laser cutting.
 */
export class ExportManager {
  private symmetryManager: SymmetryManager;
  private config: ExportConfig;

  constructor(symmetryManager: SymmetryManager, config: ExportConfig = DEFAULT_EXPORT_CONFIG) {
    this.symmetryManager = symmetryManager;
    this.config = config;
  }

  /**
   * Updates the export configuration.
   */
  public setConfig(config: Partial<ExportConfig>): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * Generates a complete, standalone SVG document for export.
   * Contains only the snowflake paths with laser-cutter compatible styling.
   * 
   * @returns SVG document as a string
   */
  public generateSVG(): string {
    const { strokeColor, strokeWidth, viewBoxSize, includeBackground } = this.config;
    
    // Get all paths with transforms baked in
    const paths = this.symmetryManager.generateBakedPaths();
    
    if (paths.length === 0) {
      throw new Error('No paths to export. Please draw something first.');
    }
    
    // Build SVG document
    let svgContent = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n`;
    svgContent += `<svg width="${viewBoxSize}" height="${viewBoxSize}" `;
    svgContent += `viewBox="0 0 ${viewBoxSize} ${viewBoxSize}" `;
    svgContent += `xmlns="http://www.w3.org/2000/svg" `;
    svgContent += `xmlns:xlink="http://www.w3.org/1999/xlink">\n`;
    
    // Add metadata
    svgContent += `  <title>Snowflake Design</title>\n`;
    svgContent += `  <desc>Generated by Snowflake Creator - 12-fold symmetry - Laser cutting compatible</desc>\n`;
    
    // Optional background circle for reference
    if (includeBackground) {
      svgContent += `  <circle cx="${viewBoxSize / 2}" cy="${viewBoxSize / 2}" r="${viewBoxSize * 0.4}" `;
      svgContent += `fill="none" stroke="#E0E0E0" stroke-width="1" />\n`;
    }
    
    // Add all paths with laser-cutting attributes
    svgContent += `  <g id="snowflake">\n`;
    for (const path of paths) {
      const d = path.getAttribute('d');
      if (d) {
        svgContent += `    <path d="${d}" `;
        svgContent += `fill="none" `;
        svgContent += `stroke="${strokeColor}" `;
        svgContent += `stroke-width="${strokeWidth}" `;
        svgContent += `stroke-linecap="round" `;
        svgContent += `stroke-linejoin="round" />\n`;
      }
    }
    svgContent += `  </g>\n`;
    
    svgContent += `</svg>`;
    
    return svgContent;
  }

  /**
   * Exports the snowflake as an SVG file and triggers a download.
   * 
   * @param filename - The name of the file to download (default: "snowflake.svg")
   */
  public exportToFile(filename: string = 'snowflake.svg'): void {
    try {
      const svgContent = this.generateSVG();
      
      // Create a blob and download link
      const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      link.style.display = 'none';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Clean up the URL
      setTimeout(() => URL.revokeObjectURL(url), 100);
      
      console.log(`Exported snowflake to ${filename}`);
    } catch (error) {
      console.error('Export failed:', error);
      alert(error instanceof Error ? error.message : 'Export failed');
    }
  }

  /**
   * Generates a data URL for the SVG (useful for previews).
   * 
   * @returns Data URL containing the SVG
   */
  public generateDataURL(): string {
    const svgContent = this.generateSVG();
    return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgContent)}`;
  }

  /**
   * Copies the SVG content to the clipboard.
   */
  public async copyToClipboard(): Promise<void> {
    try {
      const svgContent = this.generateSVG();
      await navigator.clipboard.writeText(svgContent);
      console.log('SVG copied to clipboard');
    } catch (error) {
      console.error('Failed to copy to clipboard:', error);
      throw error;
    }
  }
}

/**
 * Utility function to validate SVG for laser cutting compatibility.
 * Checks for common issues that might cause problems.
 * 
 * @param svgContent - The SVG content to validate
 * @returns Object with validation results and warnings
 */
export function validateForLaserCutting(svgContent: string): {
  valid: boolean;
  warnings: string[];
  errors: string[];
} {
  const warnings: string[] = [];
  const errors: string[] = [];
  
  // Check for filled shapes (laser cutters typically only cut strokes)
  if (svgContent.includes('fill="') && !svgContent.includes('fill="none"')) {
    warnings.push('SVG contains filled shapes. Laser cutters typically only process stroke paths.');
  }
  
  // Check for very thin strokes
  const strokeWidthMatch = svgContent.match(/stroke-width="([\d.]+)"/);
  if (strokeWidthMatch) {
    const width = parseFloat(strokeWidthMatch[1]);
    if (width > 1) {
      warnings.push(`Stroke width (${width}) is larger than typical laser cutting hairline (0.1-0.5).`);
    }
  }
  
  // Check for transforms (should be baked)
  if (svgContent.includes('transform="')) {
    warnings.push('SVG contains transform attributes. These should be baked into coordinates.');
  }
  
  // Check for embedded images or unsupported elements
  if (svgContent.includes('<image') || svgContent.includes('<text')) {
    errors.push('SVG contains unsupported elements (images or text) for laser cutting.');
  }
  
  return {
    valid: errors.length === 0,
    warnings,
    errors,
  };
}
